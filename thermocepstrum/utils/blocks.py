#!/usr/bin/env python  

import sys
import os
abs_path=os.path.abspath(sys.argv[0])        
tc_path = abs_path[:abs_path.rfind('/')] 
tc_path = tc_path[:tc_path.rfind('/')]
sys.path.append(tc_path[:tc_path.rfind('/')])
print tc_path
                                        
import numpy as np                                    
import scipy as sp                                    
import scipy.stats
import matplotlib                                     
matplotlib.use('Agg')                                 
import matplotlib.pyplot as plt                       
from matplotlib.backends.backend_pdf import PdfPages  
plt.rcParams['figure.figsize'] = (16, 9)
plt.style.reload_library()
plt.style.use(tc_path+'/grafici_belli.mplstyle')
plt.rc('text', usetex=True)
c = plt.rcParams['axes.prop_cycle'].by_key()['color'] 
from matplotlib.ticker import MultipleLocator
import math
import os.path
import thermocepstrum as tc

def main():
     usage="""usage: {} output N_currents N_processes DT_FS input1 input2 ... inputN
     
        N must be at least 2.
        This utility computes some histograms and statistics of the outputs generated by the analysis program.
        N_processes is the number of independent processes used, and N_currents is the number of currents in every random process.
        DT_FS is the timestep in femtoseconds.
     
        Riccardo Bertossa (SISSA), 2018
     
     """.format(sys.argv[0])
     
     #number of elements of the periodogram used in making the big histogram
     all_cut=1500
     
     if len(sys.argv) < 7:
          print usage
          exit(-1)
     
     output=sys.argv[1]
     M=int(sys.argv[2])
     L=int(sys.argv[3])
     dof=L-M+1
     print dof, ' degrees of freedom for the chi2 distribution'
     ndata=len(sys.argv)-5
     DT_FS=float(sys.argv[4])
     ff=5
     
     print "Number of inputs: {}\n reading...".format(ndata)
     periodograms=[]
     cospectrums=[]
     cepstrals=[]
     aic_Kmins=np.zeros(ndata)
     kappas_Kmin=np.zeros(ndata)
     kappa_scales=np.zeros(ndata)
     if os.path.isfile(sys.argv[ff]+'.psd.npy'):
         freqs=np.load(sys.argv[ff]+'.psd.npy')[0]
     else:
         freqs=np.loadtxt(sys.argv[ff]+'.psd.dat',usecols=(0,),unpack=True)
     cont=0
     for fname in sys.argv[ff:]:
         print fname
         if os.path.isfile(fname+'.psd.npy'):
             periodograms.append(np.load(fname+'.psd.npy')[3:5])
         else:
             periodograms.append(np.loadtxt(fname+'.psd.dat',usecols=(3,4),unpack=True))
         if os.path.isfile(fname+'.cepstral.npy'):
             cepstrals.append(np.load(fname+'.cepstral.npy')[4:6])
         else:
             cepstrals.append(np.loadtxt(fname+'.cepstral.dat',usecols=(4,5),unpack=True))
     
         if os.path.isfile(fname+'.cospectrum.npy'):
             cospectrums.append(np.load(fname+'.cospectrum.npy')[1]/L)
         
         if len(cospectrums)==0:
             cospectrums=None 

         fka=open(fname+'.kappa_scale_aicKmin.dat')
         kappa_scales[cont]=float(fka.readline())
         aic_Kmin=int(fka.readline())
         aic_Kmins[cont]=aic_Kmin
         fka.close()
     
         kappas_Kmin[cont]=cepstrals[cont][0,aic_Kmin]
     
     
         cont+=1
         
     aic_KminM=np.mean(aic_Kmins)
     aic_Kmin=int(aic_KminM)
     print 'Reading done.'
     
     print 'Mean value of kappa_scale: {}'.format(np.mean(kappa_scales))
     print 'Mean value of minimum of AIC: {}'.format(aic_KminM)
     
     #resizing and creating a big numpy array.
     for periodogram,cepstral in zip(periodograms,cepstrals):
         periodogram.resize(periodograms[0].shape)
         cepstral.resize(cepstrals[0].shape)
     
     cepstrals=np.array(cepstrals,copy=False)
     periodograms=np.array(periodograms,copy=False)
     
     #calculate statistics over first axis
     std_periodogram=np.std(periodograms,axis=0,ddof=1)
     std_cepstral=np.std(cepstrals,axis=0,ddof=1)
     mean_periodogram=np.mean(periodograms,axis=0)
     mean_cospectrum=None
     if cospectrums!=None:
         mean_cospectrum=np.mean(cospectrums,axis=0)
     mean_cepstral=np.mean(cepstrals,axis=0)
     print mean_cepstral.shape
     print mean_periodogram.shape
     np.savetxt(output+'.mean_periodogram',np.c_[freqs,mean_periodogram[0],std_periodogram[0],mean_periodogram[1],std_periodogram[1]])
     np.savetxt(output+'.mean_cepstral',np.c_[mean_cepstral[0],std_cepstral[0],mean_cepstral[1],std_cepstral[1]])
     
     
     print 'Mean values and standard deviations done.'
     
     print 'Computing index of .40 psd power...'
     psd_int=np.cumsum(mean_periodogram[0])
     psd_int=psd_int/psd_int[-1]
     p95=0
     while psd_int[p95]<0.10:
         p95=p95+1
     all_cut=p95

     all_cut=100     

     #select only components that are significantly different from zero
     selection_not_zero=[]
     zero=mean_periodogram[0,0]/10
     for i in range(all_cut):
         if mean_periodogram[0,i]>zero:
             selection_not_zero.append(i)
     print 'Number of components > {}: {}. Last is {}'.format(zero,len(selection_not_zero),selection_not_zero[-1])
#     print selection_not_zero

     print 'Index = {} , {} THz'.format(p95,freqs[p95])
     
     print 'Some plots...'
     #make some plots and histograms
     
     with PdfPages(output+"_all.pdf") as pdf:
         plt.fill_between(freqs,mean_periodogram[0]-std_periodogram[0],mean_periodogram[0]+std_periodogram[0])
         plt.plot(freqs,mean_periodogram[0])
         plt.title('Original PSD')
         pdf.savefig()
         plt.close()

         class Psd:
            psd=None
            fpsd=None
            freqs_THz=None
            kappa_scale=None
            cospectrum=None
            DT_FS=None
            def ffpsd(self,w):
                WF=int(round(w/1000.*self.DT_FS*len(self.freqs_THz)*2.))
                print 'filtering: ',WF
                ffpsd=tc.md.tools.runavefilter(self.fpsd, WF)
                self.fpsd=ffpsd
                try:
                 for i in range(self.cospectrum.shape[0]):
                  for j in range(self.cospectrum.shape[1]):
                   ffpsd=tc.md.tools.runavefilter(self.cospectrum[i,j], WF)
                   self.cospectrum[i,j]=ffpsd
                except AttributeError:
                 pass
                 

         psd=Psd()

         psd.DT_FS=DT_FS
         psd.kappa_scale=np.mean(kappa_scales)/DT_FS
         psd.psd=periodograms[0,0,:]
         psd.fpsd=mean_periodogram[0,:]
         psd.freqs_THz=freqs
         psd.cospectrum=mean_cospectrum
         psd.ffpsd(0.2)

         plt_psd(psd,k_00=True)
         pdf.savefig()
         plt.close()
     
         #make histogram for component 0 and 1 of psd
        
         #compute means without i-th element
         independent_mean=np.zeros((periodograms.shape[0],periodograms.shape[2]))
         for i in range(periodograms.shape[0]):
             all_but_ith=[x for x in range(periodograms.shape[0]) if x != i]
             independent_mean[i,:]= np.mean(periodograms[all_but_ith,0,:],axis=0)
 
         plt.hist(kappas_Kmin)
         plt.title('kappa(aic-Kmin)') 
         pdf.savefig()
         plt.close()
        
         data1=periodograms[:,0,0]/independent_mean[:,0]    
        
         ks__0=plt_hist_single_psd(data1,dof)
         pdf.savefig() 
         plt.close()
     
         data2=periodograms[:,0,1]/independent_mean[:,1]  
         ks__1=plt_hist_single_psd(data2,dof*2)
         pdf.savefig()
         plt.close()
     
         #ks_1=sp.stats.kstest(data2*2*dof,sp.stats.chi2(2*dof).cdf)
        
         #make histogram for all components normalized
         all_normalized=np.zeros(periodograms.shape[0]*(len(selection_not_zero)))
         for i in range(periodograms.shape[0]):
         #for idx,i in enumerate(selection_not_zero):
             all_normalized[i*len(selection_not_zero):(i+1)*len(selection_not_zero)]=periodograms[i,0,selection_not_zero]/independent_mean[i,selection_not_zero]
     
         ks_all=plt_hist_single_psd(all_normalized,dof*2,nbins=100)
         pdf.savefig()                       
         plt.close()
     
#         np.savetxt(output+'.histogram_all',np.c_[(intervals[1:]+intervals[:-1])/2.0,histogram/np.sum(histogram)])
#         print 'Histogram bin width: {}'.format(intervals[1]-intervals[0])
     
#         np.savetxt(output+'.kolmogorov_smirnov',[ks_0,ks_1,ks_all])
         print 'Statistical test results (psd(0), psd(1), psd(all but 0)): {}'.format([ks__0,ks__1,ks_all])
     
         #make graphs of mean of theoretical and statistical error of the final result
         plt.fill_between(np.arange(mean_cepstral.shape[1]),mean_cepstral[0]-std_cepstral[0],mean_cepstral[0]+std_cepstral[0])
         plt.plot(np.arange(mean_cepstral.shape[1]),mean_cepstral[0]-mean_cepstral[1])
         plt.plot(np.arange(mean_cepstral.shape[1]),mean_cepstral[0]+mean_cepstral[1])
         plt.plot(np.arange(mean_cepstral.shape[1]),mean_cepstral[0])
         plt.title('Convergence of cepstral result with theoretical and statistical errors')
      
         plt.xlim([0,10*aic_Kmin])
         max_y=np.amax((mean_cepstral[0]+std_cepstral[0])[aic_Kmin:3*aic_Kmin])
         min_y=np.amin((mean_cepstral[0]-std_cepstral[0])[aic_Kmin:3*aic_Kmin])
         plt.ylim([min_y*0.8,max_y*1.2])
             
     
         pdf.savefig()
         plt.close()  

def plt_hist_single_psd(data1,dof,nbins=None):
    
         fig=plt.figure(figsize=(3.8,2.3))
         if nbins != None:
             h,i,p=plt.hist(data1*dof,bins=nbins,normed=True)
         else:
             h,i,p=plt.hist(data1*dof,normed=True)

         xmax=i[-1]
         ymax=np.max(h)*1.2
         plt.xlim([0.0,xmax])
         plt.ylim([0.0,ymax])

         x=np.linspace(0.0,xmax,1000)

         plt.plot(x,sp.stats.chi2.pdf(x,dof),ls=':',label='$\chi^2_{{{}}}$'.format(dof))

         plt.xlabel('Normalized values')
         plt.ylabel('Probability')
         plt.legend()

         dx1,dx2=n_tick_in_range(0,xmax,5)
         dy1,dy2=n_tick_in_range(0,ymax,5)

         plt.axes().xaxis.set_major_locator(MultipleLocator(dx1))
         plt.axes().xaxis.set_minor_locator(MultipleLocator(dx2))
         plt.axes().yaxis.set_major_locator(MultipleLocator(dy1))
         plt.axes().yaxis.set_minor_locator(MultipleLocator(dy2))
         ks_0=sp.stats.kstest(data1*dof,sp.stats.chi2(dof).cdf)

         text='KS-value=${}$\nP=${}$'.format(as_si(ks_0[0],1),as_si(ks_0[1],1))
         plt.text(.5,.6,text,transform=fig.transFigure)

         return ks_0


def plt_psd(jf,j2=None,j2pl=None,f_THz_max=None, k_SI_max=None,k_00=False):

    if f_THz_max==None:
       idx_max=index_cumsum(jf.psd,0.95)
       f_THz_max=jf.freqs_THz[idx_max]

    if k_SI_max==None:
       k_SI_max=np.max(jf.fpsd[:int(jf.freqs_THz.shape[0]*f_THz_max/jf.freqs_THz[-1])]*jf.kappa_scale*.5) *1.3
       if k_00 :
         try:
           k_SI_max2=np.max(np.real(jf.cospectrum[0,0][:int(jf.freqs_THz.shape[0]*f_THz_max/jf.freqs_THz[-1])])*jf.kappa_scale*.5)
           if k_SI_max < k_SI_max2:
              k_SI_max = k_SI_max2
         except AttributeError:
           pass

       

    plt.figure(figsize=(3.8,2.3))
    plt.plot(jf.freqs_THz,jf.psd*jf.kappa_scale*.5,lw=0.2,c='0.8')
    plt.plot(jf.freqs_THz,jf.fpsd*jf.kappa_scale*.5,c=c[0])
    if j2 != None:
        plt.axvline(x=j2.Nyquist_f_THz,ls='--', c='k', dashes=(1.4,0.6), zorder=3)
    if j2pl != None:
       plt.plot(j2pl.freqs_THz,j2pl.dct.psd*j2pl.kappa_scale*.5,c=c[1])
    try:
       plt.plot(jf.freqs_THz,np.real(jf.cospectrum[0,0])*jf.kappa_scale*.5,c=c[2],lw=0.2,)
    except AttributeError:
       pass

    plt.ylim([0,k_SI_max])
    plt.xlim([0,f_THz_max])
    plt.xlabel('$\omega/2\pi$ (THz)')
    plt.ylabel('${}^{\ell}\hat{\underline{S}}_{\,k}$ (W/mK)')
    
    dx1,dx2=n_tick_in_range(0,f_THz_max,5)
    dy1,dy2=n_tick_in_range(0,k_SI_max,5)

    plt.axes().xaxis.set_major_locator(MultipleLocator(dx1))
    plt.axes().xaxis.set_minor_locator(MultipleLocator(dx2))
    plt.axes().yaxis.set_major_locator(MultipleLocator(dy1))
    plt.axes().yaxis.set_minor_locator(MultipleLocator(dy2))

def n_tick_in_range(beg,end,n):
    size=end-beg
    n_cifre=math.floor(math.log(size/n,10.0))
    delta=math.ceil((size/n)/10**n_cifre)*10**n_cifre
    return delta,delta/2

def index_cumsum(arr,p):
    if (p>1 or p<0):
        raise ValueError('p must be between 0 and 1')
    arr_int=np.cumsum(arr)
    arr_int=arr_int/arr_int[-1]
    idx=0
    while arr_int[idx]<p:
        idx=idx+1
    return idx


def as_si(x, ndp):
    s = '{x:0.{ndp:d}e}'.format(x=x, ndp=ndp)
    try:
        m, e = s.split('e')
    except ValueError:
        return r'0\times 10^{\infty}'
    return r'{m:s}\times 10^{{{e:d}}}'.format(m=m, e=int(e))

if __name__ == "__main__":
   main()



